#!/usr/bin/env bash
# slice-samples.sh — Slice .ogg keyboard recordings into varied-length chunks
# Filters out silent chunks, randomizes chunk duration for diversity
# Usage: bash scripts/slice-samples.sh [raw_dir] [samples_dir]
set -euo pipefail

PLUGIN_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
RAW_DIR="${1:-$PLUGIN_ROOT/raw}"
SAMPLES_DIR="${2:-$PLUGIN_ROOT/samples}"
CHUNKS_DIR="$SAMPLES_DIR/chunks"

MIN_LEN="20.0"           # Minimum chunk length (seconds)
MAX_LEN="90.0"           # Maximum chunk length (seconds)
FADE_MS="0.3"            # 300ms fade in/out for smooth transitions
MIN_PEAK_DB="-30"        # Discard chunks quieter than this

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; CYAN='\033[0;36m'; NC='\033[0m'
log()  { echo -e "${CYAN}[slice]${NC} $*"; }
warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
err()  { echo -e "${RED}[error]${NC} $*" >&2; }
ok()   { echo -e "${GREEN}[ok]${NC} $*"; }

for cmd in ffmpeg ffprobe; do
    command -v "$cmd" >/dev/null 2>&1 || { err "$cmd is required but not found"; exit 1; }
done

mkdir -p "$CHUNKS_DIR"

ogg_files=("$RAW_DIR"/*.ogg)
if [[ ! -f "${ogg_files[0]}" ]]; then
    err "No .ogg files found in $RAW_DIR"
    exit 1
fi
log "Found ${#ogg_files[@]} source recordings in $RAW_DIR"

rm -f "$CHUNKS_DIR"/*.wav
chunk_count=0
skipped=0

# Get peak volume of a wav file (volumedetect writes to stderr at info level)
get_max_db() {
    ffmpeg -nostdin -v info -i "$1" -af volumedetect -f null /dev/null 2>&1 \
      | awk -F': ' '/max_volume/ {gsub(" dB","",$2); print $2}'
}

for src in "${ogg_files[@]}"; do
    basename="$(basename "$src" .ogg)"
    total_dur=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$src")
    total_int=$(awk "BEGIN{printf \"%d\", $total_dur}")
    log "Processing: $(basename "$src") (${total_int}s)"

    pos=0
    while awk "BEGIN{exit(!($pos + 1.5 < $total_dur))}"; do
        remaining=$(awk "BEGIN{printf \"%.3f\", $total_dur - $pos}")

        # Randomize chunk duration between MIN_LEN and MAX_LEN
        dur=$(awk -v min="$MIN_LEN" -v max="$MAX_LEN" -v r="$RANDOM" \
              'BEGIN{srand(r); printf "%.3f", min + rand()*(max-min)}')

        # If remaining < dur, use remaining (if >= MIN_LEN)
        if awk "BEGIN{exit(!($remaining < $dur))}"; then
            if awk "BEGIN{exit(!($remaining < $MIN_LEN))}"; then
                break
            fi
            dur="$remaining"
        fi

        fade_out=$(awk "BEGIN{printf \"%.6f\", $dur - $FADE_MS}")
        tmpfile="$CHUNKS_DIR/${basename}_chunk_$(printf '%04d' $((chunk_count + skipped + 1))).wav"

        ffmpeg -v error -y \
            -i "$src" \
            -ss "$pos" -t "$dur" \
            -af "afade=t=in:d=$FADE_MS,afade=t=out:st=$fade_out:d=$FADE_MS" \
            -ar 48000 -ac 1 -sample_fmt s16 \
            "$tmpfile"

        # Filter out silent/quiet chunks
        max_db=$(get_max_db "$tmpfile" || echo "-inf")
        if [[ -z "$max_db" || "$max_db" == "-inf" ]] || awk "BEGIN{exit(!($max_db < $MIN_PEAK_DB))}"; then
            rm -f "$tmpfile"
            ((skipped++)) || true
            warn "  Discarded quiet chunk at ${pos}s (peak: ${max_db}dB)"
        else
            ((chunk_count++)) || true
        fi

        pos=$(awk "BEGIN{printf \"%.3f\", $pos + $dur}")
    done
done

log "Extraction complete:"
ok "  Chunks with audio: $chunk_count"
warn "  Silent/quiet chunks discarded: $skipped"

# Generate playlist — each chunk twice for density, shuffled
PLAYLIST="$SAMPLES_DIR/typing-playlist.m3u"
{
    echo "#EXTM3U"
    echo "# Generated by slice-samples.sh — $(date -Iseconds)"
    echo "# $chunk_count chunks"

    entries=()
    for f in "$CHUNKS_DIR"/*.wav; do
        # Relative path from playlist dir (samples/) to chunk file (samples/chunks/...)
        [[ -f "$f" ]] && rel="chunks/$(basename "$f")" && entries+=("$rel" "$rel")
    done
    printf '%s\n' "${entries[@]}" | shuf
} > "$PLAYLIST"

playlist_lines=$(wc -l < "$PLAYLIST")
ok "Playlist: $PLAYLIST ($playlist_lines entries)"
echo ""
ok "Setup complete!"
